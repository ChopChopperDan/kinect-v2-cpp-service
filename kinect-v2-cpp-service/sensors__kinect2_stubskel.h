//This file is automatically generated. DO NOT EDIT!

#include "sensors__kinect2.h"
#pragma once

namespace sensors
{
namespace kinect2
{

class sensors__kinect2Factory : public virtual RobotRaconteur::ServiceFactory
{
public:
virtual std::string GetServiceName();
virtual std::string DefString();
virtual RR_SHARED_PTR<RobotRaconteur::StructureStub> FindStructureStub(std::string s);
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRStructure> structin);
virtual RR_SHARED_PTR<RobotRaconteur::RRObject> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> mstructin);
virtual RR_SHARED_PTR<RobotRaconteur::ServiceStub> CreateStub(std::string objecttype, std::string path, RR_SHARED_PTR<RobotRaconteur::ClientContext> context);
virtual RR_SHARED_PTR<RobotRaconteur::ServiceSkel> CreateSkel(std::string objecttype, std::string path, RR_SHARED_PTR<RobotRaconteur::RRObject> obj, RR_SHARED_PTR<RobotRaconteur::ServerContext> context);
virtual void DownCastAndThrowException(RobotRaconteur::RobotRaconteurException& exp);
virtual RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> DownCastException(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> exp);
};

class KinectBody_stub : public virtual RobotRaconteur::StructureStub
{
public:
KinectBody_stub(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode> node) : RobotRaconteur::StructureStub(node) {}
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRObject> s);
virtual RR_SHARED_PTR<RobotRaconteur::RRStructure> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> m);
};

class KinectMultiSource_stub : public virtual RobotRaconteur::StructureStub
{
public:
KinectMultiSource_stub(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode> node) : RobotRaconteur::StructureStub(node) {}
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRObject> s);
virtual RR_SHARED_PTR<RobotRaconteur::RRStructure> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> m);
};

class Image_stub : public virtual RobotRaconteur::StructureStub
{
public:
Image_stub(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode> node) : RobotRaconteur::StructureStub(node) {}
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRObject> s);
virtual RR_SHARED_PTR<RobotRaconteur::RRStructure> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> m);
};

class DepthImage_stub : public virtual RobotRaconteur::StructureStub
{
public:
DepthImage_stub(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode> node) : RobotRaconteur::StructureStub(node) {}
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRObject> s);
virtual RR_SHARED_PTR<RobotRaconteur::RRStructure> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> m);
};

class ImageHeader_stub : public virtual RobotRaconteur::StructureStub
{
public:
ImageHeader_stub(RR_SHARED_PTR<RobotRaconteur::RobotRaconteurNode> node) : RobotRaconteur::StructureStub(node) {}
virtual RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> PackStructure(RR_SHARED_PTR<RobotRaconteur::RRObject> s);
virtual RR_SHARED_PTR<RobotRaconteur::RRStructure> UnpackStructure(RR_SHARED_PTR<RobotRaconteur::MessageElementStructure> m);
};

class async_Kinect
{
public:
virtual void async_EnableSensors(RR_SHARED_PTR<KinectMultiSource > s,boost::function<void (uint8_t, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
uint8_t async_EnableSensors(RR_SHARED_PTR<KinectMultiSource > s,boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<uint8_t>(boost::bind((void (async_Kinect::*)(RR_SHARED_PTR<KinectMultiSource >,boost::function<void (uint8_t,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_EnableSensors, this, boost::ref(s),_1,rr_timeout), rr_yield);
}
#endif

virtual void async_DisableSensors(boost::function<void (uint8_t, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
uint8_t async_DisableSensors(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<uint8_t>(boost::bind((void (async_Kinect::*)(boost::function<void (uint8_t,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_DisableSensors, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_SensorsEnabled(boost::function<void (RR_SHARED_PTR<KinectMultiSource >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<KinectMultiSource > async_SensorsEnabled(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<KinectMultiSource >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<KinectMultiSource >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_SensorsEnabled, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getColorImageHeader(boost::function<void (RR_SHARED_PTR<ImageHeader >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<ImageHeader > async_getColorImageHeader(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<ImageHeader >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<ImageHeader >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getColorImageHeader, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getDepthImageHeader(boost::function<void (RR_SHARED_PTR<ImageHeader >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<ImageHeader > async_getDepthImageHeader(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<ImageHeader >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<ImageHeader >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getDepthImageHeader, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getCurrentColorImage(boost::function<void (RR_SHARED_PTR<Image >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<Image > async_getCurrentColorImage(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<Image >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<Image >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getCurrentColorImage, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getCurrentDepthImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<DepthImage > async_getCurrentDepthImage(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<DepthImage >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<DepthImage >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getCurrentDepthImage, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getCurrentInfraredImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<DepthImage > async_getCurrentInfraredImage(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<DepthImage >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<DepthImage >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getCurrentInfraredImage, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getCurrentBodyIndexImage(boost::function<void (RR_SHARED_PTR<Image >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<Image > async_getCurrentBodyIndexImage(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<Image >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<Image >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getCurrentBodyIndexImage, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getCurrentLongExposureInfraredImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<DepthImage > async_getCurrentLongExposureInfraredImage(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<DepthImage >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<DepthImage >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getCurrentLongExposureInfraredImage, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getTrackedBodyIDs(boost::function<void (RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > > async_getTrackedBodyIDs(boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > >>(boost::bind((void (async_Kinect::*)(boost::function<void (RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getTrackedBodyIDs, this, _1,rr_timeout), rr_yield);
}
#endif

virtual void async_getDetectedBody(int32_t index,boost::function<void (RR_SHARED_PTR<KinectBody >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE) = 0;

#ifdef ROBOTRACONTEUR_USE_ASIO_SPAWN
RR_SHARED_PTR<KinectBody > async_getDetectedBody(int32_t index,boost::asio::yield_context rr_yield, int32_t rr_timeout=RR_TIMEOUT_INFINITE)
{
    return RobotRaconteur::detail::async_wrap_for_spawn<RR_SHARED_PTR<KinectBody >>(boost::bind((void (async_Kinect::*)(int32_t,boost::function<void (RR_SHARED_PTR<KinectBody >,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>)>,int32_t))&async_Kinect::async_getDetectedBody, this, boost::ref(index),_1,rr_timeout), rr_yield);
}
#endif

};
class Kinect_stub : public virtual Kinect, public virtual async_Kinect, public virtual RobotRaconteur::ServiceStub
{
public:
Kinect_stub(const std::string& path, RR_SHARED_PTR<RobotRaconteur::ClientContext> c);

virtual void RRInitStub();
virtual uint8_t EnableSensors(RR_SHARED_PTR<KinectMultiSource > s);

virtual uint8_t DisableSensors();

virtual RR_SHARED_PTR<KinectMultiSource > SensorsEnabled();

virtual RR_SHARED_PTR<ImageHeader > getColorImageHeader();

virtual RR_SHARED_PTR<ImageHeader > getDepthImageHeader();

virtual RR_SHARED_PTR<Image > getCurrentColorImage();

virtual RR_SHARED_PTR<DepthImage > getCurrentDepthImage();

virtual RR_SHARED_PTR<DepthImage > getCurrentInfraredImage();

virtual RR_SHARED_PTR<Image > getCurrentBodyIndexImage();

virtual RR_SHARED_PTR<DepthImage > getCurrentLongExposureInfraredImage();

virtual RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > > getTrackedBodyIDs();

virtual RR_SHARED_PTR<KinectBody > getDetectedBody(int32_t index);


virtual void DispatchEvent(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);
virtual void DispatchPipeMessage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);
virtual void DispatchWireMessage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);
virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallbackCall(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);
virtual void RRClose();
private:
virtual void async_EnableSensors(RR_SHARED_PTR<KinectMultiSource > s,boost::function<void (uint8_t, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_EnableSensors(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (uint8_t ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_DisableSensors(boost::function<void (uint8_t, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_DisableSensors(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (uint8_t ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_SensorsEnabled(boost::function<void (RR_SHARED_PTR<KinectMultiSource >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_SensorsEnabled(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<KinectMultiSource > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getColorImageHeader(boost::function<void (RR_SHARED_PTR<ImageHeader >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getColorImageHeader(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<ImageHeader > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getDepthImageHeader(boost::function<void (RR_SHARED_PTR<ImageHeader >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getDepthImageHeader(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<ImageHeader > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getCurrentColorImage(boost::function<void (RR_SHARED_PTR<Image >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getCurrentColorImage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<Image > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getCurrentDepthImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getCurrentDepthImage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<DepthImage > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getCurrentInfraredImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getCurrentInfraredImage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<DepthImage > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getCurrentBodyIndexImage(boost::function<void (RR_SHARED_PTR<Image >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getCurrentBodyIndexImage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<Image > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getCurrentLongExposureInfraredImage(boost::function<void (RR_SHARED_PTR<DepthImage >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getCurrentLongExposureInfraredImage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<DepthImage > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getTrackedBodyIDs(boost::function<void (RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getTrackedBodyIDs(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual void async_getDetectedBody(int32_t index,boost::function<void (RR_SHARED_PTR<KinectBody >, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > rr_handler, int32_t rr_timeout=RR_TIMEOUT_INFINITE);

protected:
virtual void rrend_getDetectedBody(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, boost::function< void (RR_SHARED_PTR<KinectBody > ,RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException>) > handler);
public:
virtual std::string RRType();
};


class Kinect_skel : public virtual RobotRaconteur::ServiceSkel
{
public:
virtual void Init(const std::string& path, RR_SHARED_PTR<RobotRaconteur::RRObject> object, RR_SHARED_PTR<RobotRaconteur::ServerContext> context);
virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallGetProperty(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);

virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallSetProperty(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);

virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallFunction(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m);

virtual void ReleaseCastObject();

virtual void RegisterEvents(RR_SHARED_PTR<RobotRaconteur::RRObject> rrobj1);

virtual void UnregisterEvents(RR_SHARED_PTR<RobotRaconteur::RRObject> rrobj1);

virtual RR_SHARED_PTR<RobotRaconteur::RRObject> GetSubObj(const std::string &name, const std::string &ind);

virtual void InitPipeServers(RR_SHARED_PTR<RobotRaconteur::RRObject> rrobj1);

virtual void InitWireServers(RR_SHARED_PTR<RobotRaconteur::RRObject> rrobj1);

virtual void DispatchPipeMessage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, uint32_t e);

virtual void DispatchWireMessage(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, uint32_t e);

virtual void InitCallbackServers(RR_SHARED_PTR<RobotRaconteur::RRObject> o);

virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallPipeFunction(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, uint32_t e);

virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallWireFunction(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, uint32_t e);

virtual RR_SHARED_PTR<void> GetCallbackFunction(uint32_t endpoint, const std::string& membername);

virtual RR_SHARED_PTR<RobotRaconteur::MessageEntry> CallMemoryFunction(RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::Endpoint> e);

virtual std::string GetObjectType();
virtual RR_SHARED_PTR<sensors::kinect2::Kinect > get_obj();

virtual RR_SHARED_PTR<sensors::kinect2::async_Kinect > get_asyncobj();

protected:
static void rr_EnableSensors(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, uint8_t ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_DisableSensors(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, uint8_t ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_SensorsEnabled(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<KinectMultiSource > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getColorImageHeader(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<ImageHeader > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getDepthImageHeader(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<ImageHeader > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getCurrentColorImage(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<Image > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getCurrentDepthImage(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<DepthImage > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getCurrentInfraredImage(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<DepthImage > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getCurrentBodyIndexImage(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<Image > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getCurrentLongExposureInfraredImage(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<DepthImage > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getTrackedBodyIDs(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<RobotRaconteur::RRArray<uint64_t > > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
static void rr_getDetectedBody(RR_WEAK_PTR<sensors::kinect2::Kinect_skel> skel, RR_SHARED_PTR<KinectBody > ret, RR_SHARED_PTR<RobotRaconteur::RobotRaconteurException> err, RR_SHARED_PTR<RobotRaconteur::MessageEntry> m, RR_SHARED_PTR<RobotRaconteur::ServerEndpoint> ep);
 public:
protected:bool rr_InitPipeServersRun;
bool rr_InitWireServersRun;
public: 
private:

};

}
}

